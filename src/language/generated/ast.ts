/******************************************************************************
 * This file was generated by langium-cli 0.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, Reference, isAstNode } from 'langium';

export interface ApplicationConfig extends AstNode {
    readonly $container: Model;
    properties: Array<ApplicationConfigProperty>
}

export const ApplicationConfig = 'ApplicationConfig';

export function isApplicationConfig(item: unknown): item is ApplicationConfig {
    return reflection.isInstance(item, ApplicationConfig);
}

export interface ApplicationConfigProperty extends AstNode {
    readonly $container: ApplicationConfig | ApplicationConfigProperty;
    key: string
    subProperties: Array<ApplicationConfigProperty>
    value: string | number
}

export const ApplicationConfigProperty = 'ApplicationConfigProperty';

export function isApplicationConfigProperty(item: unknown): item is ApplicationConfigProperty {
    return reflection.isInstance(item, ApplicationConfigProperty);
}

export interface Attribute extends AstNode {
    readonly $container: Entity;
    isArray: boolean
    isId: boolean
    isIndex: boolean
    name: IDWithKeword
    otherSide?: Reference<Attribute>
    type: Reference<Type>
}

export const Attribute = 'Attribute';

export function isAttribute(item: unknown): item is Attribute {
    return reflection.isInstance(item, Attribute);
}

export interface Dto extends AstNode {
    readonly $container: Package;
    entity?: Reference<Entity>
    name: string
    properties: Array<DtoProperty>
}

export const Dto = 'Dto';

export function isDto(item: unknown): item is Dto {
    return reflection.isInstance(item, Dto);
}

export interface DtoProperty extends AstNode {
    readonly $container: Dto;
    name: IDWithKeword
    type: Reference<Type>
}

export const DtoProperty = 'DtoProperty';

export function isDtoProperty(item: unknown): item is DtoProperty {
    return reflection.isInstance(item, DtoProperty);
}

export interface ExternalTypeMapping extends AstNode {
    readonly $container: ExternalType;
    language: string
    mapping: string
}

export const ExternalTypeMapping = 'ExternalTypeMapping';

export function isExternalTypeMapping(item: unknown): item is ExternalTypeMapping {
    return reflection.isInstance(item, ExternalTypeMapping);
}

export interface Import extends AstNode {
    readonly $container: Model | Package;
    toImport: Reference<TypeToImport>
}

export const Import = 'Import';

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import);
}

export interface Model extends AstNode {
    applicationConfig: ApplicationConfig
    imports: Array<Import>
    packages: Array<Package>
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface Type extends AstNode {
    readonly $container: Model | Package;
    name: IDWithKeword
}

export const Type = 'Type';

export function isType(item: unknown): item is Type {
    return reflection.isInstance(item, Type);
}

export interface TypeToImport extends AstNode {
    readonly $container: Model | Package;
}

export const TypeToImport = 'TypeToImport';

export function isTypeToImport(item: unknown): item is TypeToImport {
    return reflection.isInstance(item, TypeToImport);
}

export interface Entity extends TypeToImport, Type {
    attributes: Array<Attribute>
    base?: Reference<Entity>
    tableName: string
}

export const Entity = 'Entity';

export function isEntity(item: unknown): item is Entity {
    return reflection.isInstance(item, Entity);
}

export interface ExternalType extends TypeToImport, Type {
    mappings: Array<ExternalTypeMapping>
}

export const ExternalType = 'ExternalType';

export function isExternalType(item: unknown): item is ExternalType {
    return reflection.isInstance(item, ExternalType);
}

export interface Package extends TypeToImport {
    dtos: Array<Dto>
    entities: Array<Entity>
    imports: Array<Import>
    name: QualifiedName
    types: Array<ExternalType>
}

export const Package = 'Package';

export function isPackage(item: unknown): item is Package {
    return reflection.isInstance(item, Package);
}

export type RelationType = '[1..n]' | '[m..n]' | '1..1'

export type QualifiedName = string

export type IDWithKeword = string

export type Keyword = 'id' | 'index'

export type PhilyraAstType = 'ApplicationConfig' | 'ApplicationConfigProperty' | 'Attribute' | 'Dto' | 'DtoProperty' | 'ExternalTypeMapping' | 'Import' | 'Model' | 'Type' | 'TypeToImport' | 'Entity' | 'ExternalType' | 'Package';

export type PhilyraAstReference = 'Attribute:otherSide' | 'Attribute:type' | 'Dto:entity' | 'DtoProperty:type' | 'Import:toImport' | 'Entity:base';

export class PhilyraAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['ApplicationConfig', 'ApplicationConfigProperty', 'Attribute', 'Dto', 'DtoProperty', 'ExternalTypeMapping', 'Import', 'Model', 'Type', 'TypeToImport', 'Entity', 'ExternalType', 'Package'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            case Entity:
            case ExternalType: {
                return this.isSubtype(TypeToImport, supertype) || this.isSubtype(Type, supertype);
            }
            case Package: {
                return this.isSubtype(TypeToImport, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(referenceId: PhilyraAstReference): string {
        switch (referenceId) {
            case 'Attribute:otherSide': {
                return Attribute;
            }
            case 'Attribute:type': {
                return Type;
            }
            case 'Dto:entity': {
                return Entity;
            }
            case 'DtoProperty:type': {
                return Type;
            }
            case 'Import:toImport': {
                return TypeToImport;
            }
            case 'Entity:base': {
                return Entity;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
}

export const reflection = new PhilyraAstReflection();
