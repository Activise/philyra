/******************************************************************************
 * This file was generated by langium-cli 0.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, Reference, isAstNode } from 'langium';

export type InheritanceMode = 'multi' | 'single';

export type Keyword = 'id' | 'index';

export type KeywordOrId = string;

export type PortType = 'in' | 'out';

export type QualifiedName = string;

export type Type = Dto | Entity | ExternalType;

export const Type = 'Type';

export function isType(item: unknown): item is Type {
    return reflection.isInstance(item, Type);
}

export type TypeToImport = Dto | Entity | ExternalType | Package;

export const TypeToImport = 'TypeToImport';

export function isTypeToImport(item: unknown): item is TypeToImport {
    return reflection.isInstance(item, TypeToImport);
}

export interface ApplicationConfig extends AstNode {
    readonly $container: Model;
    properties: Array<ApplicationConfigProperty>
}

export const ApplicationConfig = 'ApplicationConfig';

export function isApplicationConfig(item: unknown): item is ApplicationConfig {
    return reflection.isInstance(item, ApplicationConfig);
}

export interface ApplicationConfigProperty extends AstNode {
    readonly $container: ApplicationConfig | ApplicationConfigProperty;
    key: string
    subProperties: Array<ApplicationConfigProperty>
    value: number | string
}

export const ApplicationConfigProperty = 'ApplicationConfigProperty';

export function isApplicationConfigProperty(item: unknown): item is ApplicationConfigProperty {
    return reflection.isInstance(item, ApplicationConfigProperty);
}

export interface Attribute extends AstNode {
    readonly $container: Entity;
    isArray: boolean
    isId: boolean
    isIndex: boolean
    name: Keyword | string
    otherSide?: Reference<Attribute>
    type: Reference<Type>
}

export const Attribute = 'Attribute';

export function isAttribute(item: unknown): item is Attribute {
    return reflection.isInstance(item, Attribute);
}

export interface CombinedIndex extends AstNode {
    readonly $container: Entity;
    attributes: Array<Reference<Attribute>>
}

export const CombinedIndex = 'CombinedIndex';

export function isCombinedIndex(item: unknown): item is CombinedIndex {
    return reflection.isInstance(item, CombinedIndex);
}

export interface Crud extends AstNode {
    readonly $container: Package;
    entities: Array<Reference<Entity>>
    forAll: boolean
}

export const Crud = 'Crud';

export function isCrud(item: unknown): item is Crud {
    return reflection.isInstance(item, Crud);
}

export interface Dto extends AstNode {
    readonly $container: Model | Package;
    entity?: Reference<Entity>
    name: Keyword | string
    properties: Array<DtoProperty>
}

export const Dto = 'Dto';

export function isDto(item: unknown): item is Dto {
    return reflection.isInstance(item, Dto);
}

export interface DtoProperty extends AstNode {
    readonly $container: Dto;
    isArray: boolean
    name: Keyword | string
    type: Reference<Type>
}

export const DtoProperty = 'DtoProperty';

export function isDtoProperty(item: unknown): item is DtoProperty {
    return reflection.isInstance(item, DtoProperty);
}

export interface Entity extends AstNode {
    readonly $container: Model | Package;
    attributes: Array<Attribute>
    base?: Reference<Entity>
    combinedIndices: Array<CombinedIndex>
    inheritance: InheritanceMode
    name: Keyword | string
    tableName: string
}

export const Entity = 'Entity';

export function isEntity(item: unknown): item is Entity {
    return reflection.isInstance(item, Entity);
}

export interface ExternalType extends AstNode {
    readonly $container: Model | Package;
    mappings: Array<ExternalTypeMapping>
    name: Keyword | string
}

export const ExternalType = 'ExternalType';

export function isExternalType(item: unknown): item is ExternalType {
    return reflection.isInstance(item, ExternalType);
}

export interface ExternalTypeMapping extends AstNode {
    readonly $container: ExternalType;
    language: string
    mapping: string
}

export const ExternalTypeMapping = 'ExternalTypeMapping';

export function isExternalTypeMapping(item: unknown): item is ExternalTypeMapping {
    return reflection.isInstance(item, ExternalTypeMapping);
}

export interface Import extends AstNode {
    readonly $container: Model | Package;
    toImport: Reference<TypeToImport>
}

export const Import = 'Import';

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import);
}

export interface MethodDefinition extends AstNode {
    readonly $container: Port;
    isArray: boolean
    name: Keyword | string
    parameters: Array<MethodParameter>
    type: Reference<Type>
}

export const MethodDefinition = 'MethodDefinition';

export function isMethodDefinition(item: unknown): item is MethodDefinition {
    return reflection.isInstance(item, MethodDefinition);
}

export interface MethodParameter extends AstNode {
    readonly $container: MethodDefinition;
    isArray: boolean
    name: Keyword | string
    type: Reference<Type>
}

export const MethodParameter = 'MethodParameter';

export function isMethodParameter(item: unknown): item is MethodParameter {
    return reflection.isInstance(item, MethodParameter);
}

export interface Model extends AstNode {
    applicationConfig: ApplicationConfig
    imports: Array<Import>
    packages: Array<Package>
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface Package extends AstNode {
    readonly $container: Model | Package;
    crud: Crud
    dtos: Array<Dto>
    entities: Array<Entity>
    imports: Array<Import>
    name: QualifiedName
    ports: Array<Port>
    repository: Repository
    types: Array<ExternalType>
}

export const Package = 'Package';

export function isPackage(item: unknown): item is Package {
    return reflection.isInstance(item, Package);
}

export interface Port extends AstNode {
    readonly $container: Package;
    isSplitted: boolean
    methods: Array<MethodDefinition>
    name: string
    type: PortType
}

export const Port = 'Port';

export function isPort(item: unknown): item is Port {
    return reflection.isInstance(item, Port);
}

export interface Repository extends AstNode {
    readonly $container: Package;
    entities: Array<Reference<Entity>>
    forAll: boolean
}

export const Repository = 'Repository';

export function isRepository(item: unknown): item is Repository {
    return reflection.isInstance(item, Repository);
}

export type PhilyraAstType = 'ApplicationConfig' | 'ApplicationConfigProperty' | 'Attribute' | 'CombinedIndex' | 'Crud' | 'Dto' | 'DtoProperty' | 'Entity' | 'ExternalType' | 'ExternalTypeMapping' | 'Import' | 'MethodDefinition' | 'MethodParameter' | 'Model' | 'Package' | 'Port' | 'Repository' | 'Type' | 'TypeToImport';

export type PhilyraAstReference = 'Attribute:otherSide' | 'Attribute:type' | 'CombinedIndex:attributes' | 'Crud:entities' | 'Dto:entity' | 'DtoProperty:type' | 'Entity:base' | 'Import:toImport' | 'MethodDefinition:type' | 'MethodParameter:type' | 'Repository:entities';

export class PhilyraAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['ApplicationConfig', 'ApplicationConfigProperty', 'Attribute', 'CombinedIndex', 'Crud', 'Dto', 'DtoProperty', 'Entity', 'ExternalType', 'ExternalTypeMapping', 'Import', 'MethodDefinition', 'MethodParameter', 'Model', 'Package', 'Port', 'Repository', 'Type', 'TypeToImport'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            case Dto:
            case Entity:
            case ExternalType: {
                return this.isSubtype(TypeToImport, supertype) || this.isSubtype(Type, supertype);
            }
            case Package: {
                return this.isSubtype(TypeToImport, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(referenceId: PhilyraAstReference): string {
        switch (referenceId) {
            case 'Attribute:otherSide': {
                return Attribute;
            }
            case 'Attribute:type': {
                return Type;
            }
            case 'CombinedIndex:attributes': {
                return Attribute;
            }
            case 'Crud:entities': {
                return Entity;
            }
            case 'Dto:entity': {
                return Entity;
            }
            case 'DtoProperty:type': {
                return Type;
            }
            case 'Entity:base': {
                return Entity;
            }
            case 'Import:toImport': {
                return TypeToImport;
            }
            case 'MethodDefinition:type': {
                return Type;
            }
            case 'MethodParameter:type': {
                return Type;
            }
            case 'Repository:entities': {
                return Entity;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
}

export const reflection = new PhilyraAstReflection();
